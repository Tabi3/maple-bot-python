from http.client import HTTPException
from Maple_bot_functions.ExternalLibraries import *
from Maple_bot_functions.MapleWebScraper import HentaiHaven, get_by_tags, get_video, rule34_by_url

class View(nextcord.ui.View):
    def __init__(self, *, timeout: float = 120, auto_defer: bool = True, item=None):
        super().__init__(timeout=timeout, auto_defer=auto_defer)
        self.add_item(item)
        
class HavenSelect(nextcord.ui.Select):
    def __init__(self, index=0) -> None:
        options = HentaiHaven()
        options = dict(list(options.items())[25*index:min((index+1)*25, len(options))])
        myoptions = [
            nextcord.SelectOption(label=i, description=options[i][0][:100])
            for i in options
        ]
        self._HavenDict = options
        super().__init__(placeholder="Selected Title", options=myoptions)

    async def callback(self, interaction: nextcord.Interaction):

        video = get_video({self.values[0]: self._HavenDict[self.values[0]]})
        embed = nextcord.Embed(title=video['title'], description=", ".join(f'`{i}`' for i in video['tags']),
                               url=video['url/image'][0], color=0x2D142C)\
            .add_field(name='Episodes', value=''.join(f'[Episode {i}]({j})\n' for i, j in enumerate(video['episodes'])))\
            .add_field(name='description', value=video['description'][:1024])\
            .set_image(url=video['url/image'][1])
        return await interaction.response.edit_message(embed=embed)


class Rule34Select(nextcord.ui.Select):
    def __init__(self, tags="straight", straight=True, view=None, page=0) -> None:
        self.images, self.image_index = get_by_tags(tags, straight, page)[:25], -1
        print(page)
        self.myview, self.page = view, 0
        super().__init__(placeholder="Select a module", options=[
             nextcord.SelectOption(label=i[0], description=i[1])
            for i in self.images
        ])

    def _to_file(self, url):  # sourcery skip: instance-method-first-arg-name
        resp, ext = __import__("requests").get(url).content, url.split(".")[-1].split("?")[0]
        with open(f'./file_buffers/{(file_id := str(__import__("uuid").uuid4()))}.{ext}', 'wb') as handler:
            handler.write(resp)
        return f"./file_buffers/{file_id}.{ext}"
    
    async def callback(self, interaction: nextcord.Interaction, view=None):
        import os, asyncio
        msg = await interaction.response.send_message('wait')
        rule34 = rule34_by_url(self.values[0])
        fp = self._to_file(rule34[1])
        embed = nextcord.Embed(title="Rule 34 Result", url=self.values[0], description=', '.join(rule34[0]['tag-type-general'],), color=0xAAF0D1)
        [embed.add_field(name=i, value=', '.join(rule34[0][i])) for i in rule34[0] if i != 'tag-type-general'][-1].set_image(url=rule34[1])
        self.image_index = [i[0] for i in self.images].index(self.values[0])
        ((_view := {"view": view or self.myview, "ephemeral": True}).update({"embed": embed} if rule34[1]
        .split('?')[0].split('.')[-1].lower() not in "mp4 mov wmv avi mkv" else {"embed": embed, "file": nextcord.File(fp=fp)}))
        file = _view.pop('file') if "file" in _view else ...
        await interaction.followup.send(**_view)
        await msg.delete()
        if rule34[1].split('?')[0].split('.')[-1].lower() in "mp4 mov wmv avi mkv":
            try:
                if (os.stat(fp).st_size/(1024*1024)) < 8 :
                    await interaction.followup.send(file=file, ephemeral=True)
                else: 
                    raise HTTPException
            except HTTPException:
                await interaction.followup.send(rule34[1], ephemeral=True)

        del file
        await asyncio.sleep(3)
        os.remove(fp)


class HelpSelect(nextcord.ui.Select):
    def __init__(self, client) -> None:
        self.client, self.bot_cogs, cogs = client, client.cogs, client.cogs
        super().__init__(placeholder="Select a module", options=[
            nextcord.SelectOption(label=cog, description=cogs[cog].__doc__ or "No description provided")
            for cog in cogs if len(cogs[cog].get_commands())
        ])

    async def callback(self, interaction: nextcord.Interaction):
        cogs, cog, commands, prefix = self.bot_cogs, self.values[0], self.client.get_cog(
            self.values[0]).get_commands(), self.client.command_prefix(..., interaction)
        embed = nextcord.Embed(
            title=cog, description=cogs[cog].__doc__ or "No description provided", color=0xF1828D).add_field(
            name='Command names', value='`' + ('\n'.join(i.name for i in commands)) + '`').add_field(
            name='Command Sytax', value='`' +
            ('\n'.join(' '.join(f"<{i.split(',')[0]}>" for i in command.__dict__['params'] 
            if i not in "self _ ctx ") or '<...>' for command in commands) or '...') + '`').add_field(
            name='Command Description', value='`' + ('\n'.join(i.help or "..." for i in commands) + '`')) if cog != 'Help' else nextcord.Embed(
            title="Bot Help",
            description="Hello there, I'm Maple, developed by Taf√≠üçÉ#1290 in 2022 Around April.\n"
            "Welcome to the help page, for more info on a command\n", color=0xF1828D).add_field(
            name="Command execution syntax", value=f"`{prefix}<command name> <args>` or\n"
            "`/<command name> <args>`")

        await interaction.response.edit_message(embed=embed)



